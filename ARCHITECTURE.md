# Архитектура проекта Web4

## Общая структура проекта

Проект состоит из двух основных частей:
- **Backend (Web4)**: Java EE приложение на базе WildFly
- **Frontend (Web4Frontend)**: React + Redux SPA приложение

## Архитектура Backend (Java EE)

### Технологический стек

- **Java 17**: Язык программирования
- **Jakarta EE**: Платформа для enterprise приложений
- **EJB (Enterprise JavaBeans)**: Бизнес-логика приложения
- **JAX-RS (REST API)**: RESTful веб-сервисы
- **JPA (Java Persistence API)**: Работа с базой данных
- **EclipseLink**: Реализация JPA провайдера
- **Apache Derby**: Встроенная база данных
- **BCrypt**: Хэширование паролей

### Структура пакетов

```
org.example/
├── entity/          # JPA сущности (модель данных)
├── dto/             # Data Transfer Objects (для REST API)
├── ejb/             # Enterprise JavaBeans (бизнес-логика)
├── rest/            # REST API ресурсы
├── util/            # Утилиты
├── bean/            # CDI бины (не используются, директория пустая)
└── service/         # Сервисы (не используются, директория пустая)
```

### Компоненты Backend

#### 1. Entity Layer (JPA сущности)

**`User.java`** - Сущность пользователя
- **Назначение**: Представляет пользователя в базе данных
- **Аннотации**:
  - `@Entity` - JPA сущность
  - `@Table(name = "users")` - имя таблицы в БД
  - `@NamedQuery` - именованный запрос для поиска по username
- **Поля**:
  - `id` (Long) - первичный ключ, автоинкремент (`@GeneratedValue(strategy = GenerationType.IDENTITY)`)
  - `username` (String) - уникальное имя пользователя
  - `passwordHash` (String) - хэш пароля (BCrypt)
- **Почему так**: Используется `GenerationType.IDENTITY` для совместимости с Derby `GENERATED ALWAYS AS IDENTITY`

**`Result.java`** - Сущность результата проверки
- **Назначение**: Хранит результаты проверки точек
- **Поля**:
  - `id` (Long) - первичный ключ
  - `x, y, r` (BigDecimal) - координаты и радиус с точностью `DECIMAL(31,15)`
  - `hit` (Boolean) - результат попадания
  - `timestamp` (LocalDateTime) - время проверки
  - `executionTime` (Long) - время выполнения в микросекундах
  - `user` (User) - связь ManyToOne с пользователем
- **Почему BigDecimal**: Для точных вычислений без потери точности
- **Почему DECIMAL(31,15)**: Максимальная точность для Apache Derby

#### 2. DTO Layer (Data Transfer Objects)

**`ResultDTO.java`** - DTO для передачи результатов
- **Назначение**: Преобразование Entity в формат для REST API
- **Особенность**: X, Y, R хранятся как `String` вместо `BigDecimal`
- **Почему String**: Для сохранения полной точности при сериализации в JSON (избегаем проблем с floating-point)

**`PointRequest.java`** - DTO для запроса проверки точки
- **Назначение**: Принимает координаты от клиента
- **Поля**: `x, y, r` (BigDecimal) - автоматически десериализуются из JSON

**`AuthResponse.java`** - DTO для ответа аутентификации
- **Назначение**: Возвращает результат входа/регистрации
- **Поля**: `success`, `message`, `userId`, `username`

**`LoginRequest.java`** - DTO для запроса входа/регистрации
- **Назначение**: Принимает credentials от клиента

#### 3. EJB Layer (Бизнес-логика)

**`UserEJB.java`** - Stateless EJB для работы с пользователями
- **Тип**: `@Stateless` - без состояния, может обрабатывать множество запросов параллельно
- **Методы**:
  - `findByUsername()` - поиск пользователя по имени
  - `createUser()` - создание нового пользователя с хэшированием пароля
  - `validatePassword()` - проверка пароля через BCrypt
  - `authenticate()` - аутентификация пользователя
  - `findById()` - поиск по ID
- **Почему Stateless**: Не хранит состояние между вызовами, подходит для REST API
- **Транзакции**: Использует `RESOURCE_LOCAL` транзакции (явное управление через `em.getTransaction()`)

**`ResultEJB.java`** - Stateless EJB для работы с результатами
- **Методы**:
  - `checkPoint()` - проверка точки на попадание в область и сохранение результата
  - `getResultsByUser()` - получение всех результатов пользователя
  - `clearResultsByUser()` - удаление всех результатов пользователя
- **Особенность**: Измеряет время выполнения проверки (`System.nanoTime()`)

**`PersistenceInitializer.java`** - Singleton EJB для инициализации БД
- **Тип**: `@Singleton @Startup` - создается один раз при старте приложения
- **Назначение**: Создает таблицы в БД при первом запуске
- **Почему Singleton**: Нужен только один экземпляр для инициализации
- **Почему @Startup**: Выполняется автоматически при развертывании приложения
- **Метод**: `initialize()` - вызывается через `@PostConstruct`
- **Логика**: Пытается создать таблицы, игнорирует ошибку "уже существует"

#### 4. REST API Layer

**`ApplicationConfig.java`** - Конфигурация JAX-RS приложения
- **Назначение**: Регистрирует все REST ресурсы
- **Аннотация**: `@ApplicationPath("/api")` - базовый путь для всех REST endpoints
- **Регистрация**: Явно регистрирует `AuthResource`, `ResultResource`, `CorsFilter`

**`AuthResource.java`** - REST ресурс для аутентификации
- **Путь**: `/api/auth`
- **Endpoints**:
  - `POST /api/auth/login` - вход пользователя
  - `POST /api/auth/register` - регистрация нового пользователя
- **Логика**: Использует `UserEJB` для работы с пользователями

**`ResultResource.java`** - REST ресурс для работы с результатами
- **Путь**: `/api/results`
- **Endpoints**:
  - `POST /api/results/check?userId={id}` - проверка точки
  - `GET /api/results?userId={id}` - получение всех результатов
  - `DELETE /api/results?userId={id}` - удаление всех результатов
- **Особенность**: Минимальная валидация (только проверка R > 0), остальная валидация на клиенте

**`CorsFilter.java`** - Фильтр для CORS
- **Назначение**: Разрешает cross-origin запросы от frontend
- **Тип**: `ContainerResponseFilter` - обрабатывает все ответы
- **Заголовки**: Добавляет CORS заголовки ко всем ответам

#### 5. Utility Layer

**`AreaChecker.java`** - Утилита для проверки попадания в область
- **Назначение**: Математическая проверка попадания точки в область (вариант 88744)
- **Область состоит из**:
  1. Квадрат в 4-й четверти: x от 0 до R, y от -R до 0
  2. Треугольник во 2-й четверти: вершины (0,0), (-R/2,0), (0,R/2), условие y ≤ x + R/2
  3. Четверть круга в 1-й четверти: центр (0,0), радиус R, условие x ≥ 0, y ≥ 0, x² + y² ≤ R²
- **Почему BigDecimal**: Для точных вычислений без ошибок округления
- **MathContext**: Используется для контроля точности вычислений (50 знаков, HALF_UP)

### База данных

**Конфигурация**: `persistence.xml`
- **Тип транзакций**: `RESOURCE_LOCAL` - явное управление транзакциями
- **Провайдер**: EclipseLink
- **БД**: Apache Derby
- **URL (development)**: `jdbc:derby:memory:web4db;create=true` - in-memory БД
- **URL (production)**: `jdbc:derby:/opt/web4/database/web4db;create=true` - файловая БД
- **Альтернативный файл**: `persistence-production.xml` - готовая конфигурация для production
- **Почему RESOURCE_LOCAL**: 
  - Проще для встроенной БД
  - Не требует настройки DataSource в WildFly
  - Полный контроль над транзакциями
- **Почему in-memory (development)**: 
  - Проще для разработки
  - Не требует управления файлами БД
  - Данные теряются при перезагрузке (приемлемо для лабораторной работы)
- **Почему файловая (production)**: 
  - Данные сохраняются при перезагрузке сервера
  - Подходит для production окружения

**Инициализация БД**:
- Выполняется через `PersistenceInitializer` при старте
- Создает таблицы `users` и `results` через нативный SQL
- Использует `GENERATED ALWAYS AS IDENTITY` для автоинкремента (совместимо с Derby)

## Архитектура Frontend (React + Redux)

### Технологический стек

- **React 18**: UI библиотека
- **Redux**: Управление состоянием
- **Redux Thunk**: Асинхронные actions
- **Axios**: HTTP клиент
- **Webpack**: Сборщик модулей
- **Babel**: Транспиляция ES6+ в ES5

### Структура проекта

```
Web4Frontend/
├── src/
│   ├── components/      # React компоненты
│   ├── store/           # Redux store
│   │   ├── actions/     # Redux actions
│   │   └── reducers/     # Redux reducers
│   ├── App.js           # Главный компонент
│   ├── index.js         # Точка входа
│   └── styles.css       # Глобальные стили
└── webpack.config.js    # Конфигурация Webpack
```

### Компоненты Frontend

#### 1. Главные компоненты

**`App.js`** - Корневой компонент
- **Назначение**: Управляет маршрутизацией между страницами
- **Логика**: Проверяет `isAuthenticated` из Redux store
- **Рендеринг**: Показывает `LoginPage` или `MainPage` в зависимости от авторизации
- **Инициализация**: При загрузке вызывает `checkAuth()` для проверки сохраненной сессии

**`LoginPage.js`** - Страница входа/регистрации
- **Состояние**: 
  - `username`, `password` - поля ввода
  - `isRegister` - режим (вход/регистрация)
- **Функционал**: 
  - Переключение между входом и регистрацией
  - Валидация на клиенте (required поля)
  - Отображение ошибок от сервера

**`MainPage.js`** - Основная страница приложения
- **Состояние**:
  - `x, y, r` - значения координат и радиуса
  - `yError` - ошибка валидации Y
  - `notification` - уведомления
  - `confirmDialog` - диалог подтверждения
- **Функционал**:
  - Ввод координат через форму
  - Клик по графику для выбора точки
  - Валидация Y (формат и диапазон)
  - Отправка на сервер
  - Отображение результатов в таблице

#### 2. UI компоненты

**`BelleComponents.js`** - Кастомные компоненты (замена библиотеки Belle)
- **TextInput**: Текстовое поле ввода
  - Поддержка `onInput` для мгновенной валидации
  - Стилизация в стиле Belle
- **Button**: Кнопка
  - Hover эффекты
  - Disabled состояние
- **Checkbox**: Чекбокс
  - Стилизация в стиле Belle

**`Canvas.js`** - Компонент для отрисовки графика
- **Технология**: HTML5 Canvas API
- **Функционал**:
  - Отрисовка координатных осей
  - Отрисовка области попадания (3 фигуры)
  - Отрисовка точек из результатов
  - Обработка кликов для выбора точки
- **Особенность**: Учитывает масштаб canvas при обработке кликов
- **Перерисовка**: Автоматически при изменении `r` или `points`

**`Notification.js`** - Компонент уведомлений
- **Назначение**: Показывает временные уведомления
- **Типы**: error, warning, info, success
- **Особенность**: Автоматически исчезает через 5 секунд

**`ConfirmDialog.js`** - Диалог подтверждения
- **Назначение**: Заменяет `window.confirm()`
- **Функционал**: Модальное окно с кнопками "Отмена" и "Подтвердить"

#### 3. Redux Store

**Actions (`authActions.js`)**:
- `login()` - асинхронный action для входа
- `register()` - асинхронный action для регистрации
- `logout()` - синхронный action для выхода
- `checkAuth()` - проверка сохраненной сессии

**Actions (`resultActions.js`)**:
- `checkPoint()` - проверка точки на сервере
- `fetchResults()` - загрузка результатов пользователя
- `clearResults()` - удаление всех результатов

**Reducers**:
- `authReducer` - управляет состоянием аутентификации
- `resultReducer` - управляет состоянием результатов
- `rootReducer` - объединяет все reducers

**Почему Redux**:
- Централизованное управление состоянием
- Предсказуемые обновления состояния
- Легкая отладка через Redux DevTools
- Разделение логики и представления

#### 4. Стили и адаптивность

**`styles.css`** - Глобальные стили
- **Адаптивный дизайн**:
  - Десктопный (>= 1189px): двухколоночная сетка
  - Планшетный (766px - 1188px): одноколоночная сетка
  - Мобильный (< 766px): компактная версия
- **Особенности**:
  - Градиентный фон
  - Карточки с тенями
  - Анимации и переходы

## Взаимодействие Frontend и Backend

### Схема запросов

```
Frontend (React) 
    ↓
Redux Actions (Axios)
    ↓
REST API (/web4/api/*)
    ↓
JAX-RS Resources
    ↓
EJB (бизнес-логика)
    ↓
JPA EntityManager
    ↓
Apache Derby (БД)
```

### Протокол обмена данными

1. **Аутентификация**:
   - Frontend отправляет `POST /api/auth/login` с `{username, password}`
   - Backend проверяет через `UserEJB.authenticate()`
   - Возвращает `AuthResponse` с `userId` и `username`
   - Frontend сохраняет в `localStorage`

2. **Проверка точки**:
   - Frontend отправляет `POST /api/results/check?userId={id}` с `{x, y, r}`
   - Backend проверяет попадание через `AreaChecker.checkHit()`
   - Сохраняет результат через `ResultEJB.checkPoint()`
   - Возвращает `ResultDTO`

3. **Получение результатов**:
   - Frontend отправляет `GET /api/results?userId={id}`
   - Backend получает через `ResultEJB.getResultsByUser()`
   - Возвращает массив `ResultDTO`

### CORS (Cross-Origin Resource Sharing)

**Проблема**: Frontend на `localhost:3000`, Backend на `localhost:8080` - разные источники

**Решение**: `CorsFilter` добавляет заголовки:
- `Access-Control-Allow-Origin: *`
- `Access-Control-Allow-Methods: GET, POST, DELETE, OPTIONS`
- `Access-Control-Allow-Headers: origin, content-type, accept, authorization`

## Обработка данных

### Точность чисел

**Проблема**: JavaScript использует floating-point, Java - BigDecimal

**Решение**:
1. На frontend: X, Y, R передаются как строки
2. На backend: Автоматическая десериализация JSON в BigDecimal
3. В БД: Хранение как `DECIMAL(31,15)`
4. При возврате: Конвертация BigDecimal в String через `toPlainString()`

**Почему так**:
- Избегаем потери точности при сериализации/десериализации
- BigDecimal сохраняет точность вычислений
- String в JSON гарантирует точную передачу

### Валидация

**На клиенте** (для формы):
- Проверка формата Y (число, точка/запятая)
- Проверка диапазона Y (-5 до 5)
- Проверка выбора X и R

**На сервере** (для клика по графику):
- Минимальная валидация (только R > 0)
- Проверка попадания работает для любых координат

**Почему разная валидация**:
- Форма: Пользователь вводит данные, нужна валидация перед отправкой
- График: Пользователь кликает, координаты могут быть любыми, сервер просто проверяет попадание

## Безопасность

### Хэширование паролей

**Технология**: BCrypt
- **Почему BCrypt**: 
  - Адаптивный алгоритм (можно увеличивать сложность)
  - Встроенная соль (salt)
  - Защита от rainbow tables
- **Использование**: `BCrypt.hashpw()` для хэширования, `BCrypt.checkpw()` для проверки

### Авторизация

**Механизм**: 
- Frontend хранит `userId` в `localStorage`
- Каждый запрос включает `userId` как query parameter
- Backend проверяет существование пользователя

**Ограничения**:
- Нет JWT токенов (упрощенная реализация для лабораторной работы)
- Нет сессий на сервере
- `userId` передается в открытом виде (для production нужна улучшенная безопасность)

## Сборка и развертывание

### Backend

**Сборка**: Gradle
- Плагин `war` создает `web4.war`
- Зависимости включаются в `WEB-INF/lib/`
- **Автоматическая сборка frontend**: Задача `buildFrontend` собирает React приложение через npm
- **Автоматическое копирование**: Задача `copyFrontend` копирует собранный frontend из `Web4Frontend/dist/` в `src/main/webapp/`
- **Результат**: WAR файл содержит и backend, и frontend в одном архиве
- **Локальная сборка**: Скрипты `build-local.sh` / `build-local.bat` для автоматической сборки всего проекта
- Развертывание: Копирование WAR в `standalone/deployments/` WildFly

### Frontend

**Сборка**: Webpack
- Development: `npm start` - запускает dev-server на порту 3000
- Production: `npm run build` - создает оптимизированный bundle в `dist/`
- **PublicPath**: В production используется относительный путь `./` для работы внутри WAR
- Прокси: Запросы к `/web4` проксируются на `localhost:8080` (только в development)
- **Встраивание в WAR**: Собранные файлы автоматически копируются в WAR при сборке backend

## Выбор технологий и обоснование

### Почему Java EE (EJB)?

- **Требование ТЗ**: Использование EJB обязательно
- **Преимущества**:
  - Управление транзакциями
  - Dependency Injection через `@EJB`
  - Lifecycle management (`@Singleton`, `@Startup`)
  - Интеграция с JPA

### Почему React + Redux?

- **Требование ТЗ**: React + Redux с ES6 и JSX
- **Преимущества**:
  - Компонентный подход
  - Предсказуемое управление состоянием
  - Большая экосистема
  - Хорошая производительность

### Почему REST API?

- **Требование ТЗ**: Взаимодействие через REST API
- **Преимущества**:
  - Разделение frontend и backend
  - Легкое тестирование
  - Стандартный протокол
  - Независимая разработка

### Почему Apache Derby?

- **Требование ТЗ**: Apache Derby для хранения данных
- **Преимущества**:
  - Встроенная БД (не требует отдельного сервера)
  - Легкая настройка
  - Совместимость с JPA
  - Подходит для разработки

### Почему JPA?

- **Требование ТЗ**: Использование JPA для доступа к БД
- **Преимущества**:
  - Объектно-ориентированный доступ к БД
  - Автоматическая генерация запросов
  - Кэширование
  - Портативность между БД

### Почему RESOURCE_LOCAL транзакции?

- **Причина**: Упрощенная работа с встроенной БД
- **Альтернатива**: JTA транзакции (требуют настройки DataSource в WildFly)
- **Выбор**: RESOURCE_LOCAL для простоты и контроля

## Потоки данных

### Регистрация пользователя

```
1. Пользователь вводит username/password
2. LoginPage → dispatch(register(username, password))
3. authActions.register() → POST /api/auth/register
4. AuthResource.register() → UserEJB.createUser()
5. UserEJB → BCrypt.hashpw() → em.persist(user)
6. Возврат AuthResponse → Redux store → localStorage
```

### Проверка точки (форма)

```
1. Пользователь вводит X, Y, R и нажимает "Отправить"
2. MainPage.handleSubmit() → валидация на клиенте
3. dispatch(checkPoint(x, y, r, userId))
4. resultActions.checkPoint() → POST /api/results/check
5. ResultResource.checkPoint() → ResultEJB.checkPoint()
6. ResultEJB → AreaChecker.checkHit() → em.persist(result)
7. Возврат ResultDTO → Redux store → обновление таблицы
```

### Проверка точки (клик по графику)

```
1. Пользователь кликает на графике
2. Canvas.handleClick() → MainPage.handleCanvasClick()
3. Преобразование координат клика в координаты графика
4. dispatch(checkPoint(x, y, r, userId)) (без валидации ОДЗ)
5. resultActions.checkPoint() → POST /api/results/check
6. ResultResource.checkPoint() → проверка только R > 0
7. ResultEJB.checkPoint() → AreaChecker.checkHit() → сохранение
8. Возврат ResultDTO → Redux store → обновление графика и таблицы
```

### Загрузка результатов

```
1. MainPage загружается → useEffect → dispatch(fetchResults(userId))
2. resultActions.fetchResults() → GET /api/results?userId={id}
3. ResultResource.getResults() → ResultEJB.getResultsByUser()
4. ResultEJB → NamedQuery "Result.findByUser" → List<Result>
5. Преобразование в List<ResultDTO>
6. Возврат List<ResultDTO> → Redux store → отображение в таблице
```

## Особенности реализации

### Обработка координат клика на графике

**Проблема**: Canvas может масштабироваться через CSS, но внутренний размер остается 500x500

**Решение**: 
```javascript
const scaleX = canvas.width / rect.width;
const scaleY = canvas.height / rect.height;
const x = (e.clientX - rect.left) * scaleX;
const y = (e.clientY - rect.top) * scaleY;
```

**Почему**: Учитывает разницу между видимым размером и внутренним размером canvas

### Точность чисел при клике

**Проблема**: JavaScript floating-point может давать длинные десятичные дроби

**Решение**: Ограничение до 5 знаков после запятой
```javascript
const numberToStringWithPrecision = (num) => {
  const str = num.toFixed(5);
  return str.replace(/\.?0+$/, '') || '0';
};
```

**Почему**: Удобство для пользователя, достаточная точность для проверки

### Валидация Y с поддержкой запятой

**Проблема**: В разных локалях используется запятая как разделитель

**Решение**: 
- Разрешаем и точку, и запятую при вводе
- При отправке заменяем запятую на точку
- Регулярное выражение: `/^-?(\d+[.,]?\d*|[.,]\d+)$/`

**Почему**: Удобство для пользователей из разных регионов

### Инициализация БД

**Проблема**: EclipseLink с RESOURCE_LOCAL не всегда корректно создает таблицы

**Решение**: `PersistenceInitializer` создает таблицы вручную через нативный SQL

**Почему**: 
- Полный контроль над структурой БД
- Совместимость с Derby `GENERATED ALWAYS AS IDENTITY`
- Надежность при развертывании

### CORS фильтр

**Проблема**: Браузер блокирует cross-origin запросы

**Решение**: `CorsFilter` добавляет необходимые заголовки ко всем ответам

**Почему**: Frontend и Backend на разных портах (3000 и 8080)

## Производительность

### Оптимизации

1. **Lazy Loading**: `@ManyToOne(fetch = FetchType.LAZY)` в Result
2. **NamedQueries**: Предкомпилированные запросы
3. **Stateless EJB**: Переиспользование экземпляров
4. **React.memo**: Можно добавить для оптимизации рендеринга
5. **Webpack code splitting**: Можно добавить для уменьшения bundle

### Измерение производительности

- Время выполнения проверки точки измеряется в `ResultEJB.checkPoint()`
- Используется `System.nanoTime()` для точного измерения
- Результат сохраняется в микросекундах

## Безопасность и валидация

### Валидация на клиенте

- **Формат Y**: Регулярное выражение для проверки числа
- **Диапазон Y**: Проверка -5 до 5
- **Выбор X и R**: Проверка на null

### Валидация на сервере

- **Минимальная**: Только проверка R > 0 (для корректной работы AreaChecker)
- **Почему минимальная**: 
  - При клике по графику координаты могут быть любыми (вне ОДЗ)
  - Сервер просто проверяет попадание, не выдавая ошибку для координат вне ОДЗ
  - Это позволяет пользователю кликать в любом месте графика

### Хранение паролей

- **BCrypt**: Адаптивный алгоритм хэширования
- **Соль**: Автоматически генерируется BCrypt
- **Пароли**: Никогда не хранятся в открытом виде

## Расширяемость

### Легко добавить

1. **JWT токены**: Для улучшенной авторизации
2. **WebSocket**: Для real-time обновлений
3. **Кэширование**: Redis для результатов
4. **Логирование**: SLF4J + Logback
5. **Тестирование**: JUnit для backend, Jest для frontend

### Архитектурные решения для расширяемости

- **Разделение слоев**: Entity, DTO, EJB, REST - легко заменяемы
- **Dependency Injection**: Через `@EJB` - легко тестировать
- **Redux**: Централизованное состояние - легко добавлять функционал


